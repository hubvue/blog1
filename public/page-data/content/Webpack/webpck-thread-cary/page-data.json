{"componentChunkName":"component---src-templates-blog-post-js","path":"/content/Webpack/webpck-thread-cary/","result":{"data":{"site":{"siteMetadata":{"title":"Kim Blog","author":"Kim"}},"markdownRemark":{"id":"c51b72d9-f7b8-54ee-abd6-c29a07a05fd0","excerpt":"webpack 的痛点 one：进退两难的 loader 众所周知，webpack 打包一切，万物皆模块，成就 webpack 特性的根本就是 loader，webpack 使用 loader 加载各种文件，例如加载一个 loader：loader 首先接收到的是 string，通过 loader 解析把 string…","html":"<h2>webpack 的痛点</h2>\n<h3>one：进退两难的 loader</h3>\n<p>众所周知，webpack 打包一切，万物皆模块，成就 webpack 特性的根本就是 loader，webpack 使用 loader 加载各种文件，例如加载一个 loader：loader 首先接收到的是 string，通过 loader 解析把 string 解析成 AST，然后经过一系列处理再转成 string。所以说一个 loader 的编译是经历了<code class=\"language-text\">String-&gt;AST-&gt;String</code>的过程。</p>\n<p>上面说了 webpack 万物皆模块的优点。虽然它为我们带来了许多便利，但是它也成为了我们构建项目过程中的一个痛点，经历一个 loader 就会经历<code class=\"language-text\">String-&gt;AST-&gt;String</code>的过程，那经历三个 loader(less-loader--->css-loader--->style-loader)呢？</p>\n<blockquote>\n<p>less-loader(String->AST->String) —> css-loader(String->AST->String) —> style-loader(String->AST->String)</p>\n</blockquote>\n<p>看到这个过程，你可能会想，这 webpack 是不是傻，直接第一次转成 AST，后面的 loader 都使用这个 AST，到最后一个再转成 String 不就行了吗？很明显 webpack 没有你那么聪明，这也是它痛点的原因。</p>\n<h3>two：孤独的人生路</h3>\n<p>何为孤独人生路？webpack 是基于 node.js 来做的构建工具，其 node 本身只是一个运行时，代码还是用 JavaScript 来写的，当然也就继承了单进程单线程这一特点。webpack 基于 node，当然它也是单进程单线程的了。</p>\n<p>对比传统的多进程多线程后端语言，node 虽然不需要管理多线程之间各种锁的问题，但它也有光杆司令的忧伤。</p>\n<blockquote>\n<p>webpack 相比也内心吐槽，我一个线程程力(人叫人力，线程就叫程力吧)，哪能比过人家一群程力的力量。</p>\n</blockquote>\n<h2>有痛点必然有解痛药</h2>\n<blockquote>\n<p>心病还得心药医，止痛还需解痛药</p>\n</blockquote>\n<h3>one：一解 loader 勇往直前</h3>\n<p>既然 loader 每次都要经历这么一个过程，那么我缓存不就可以了吗？</p>\n<p>目前来说使用最多的就是<code class=\"language-text\">cache-loader</code>。</p>\n<p>安装</p>\n<blockquote>\n<p>npm install cache-loader —save-dev or yarn add cache-loader —dev</p>\n</blockquote>\n<p><code class=\"language-text\">cache-loader</code>的使用方式很简单，想缓存哪个 loader，只需要在特定 loader 的前面加上<code class=\"language-text\">cache-loader</code>就可以了</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  module<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    rules<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token punctuation\">{</span>\n        test<span class=\"token punctuation\">:</span> <span class=\"token regex\">/\\.css$/</span><span class=\"token punctuation\">,</span>\n        use<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n          <span class=\"token punctuation\">{</span>\n            loader<span class=\"token punctuation\">:</span> <span class=\"token string\">'cache-loader'</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          <span class=\"token punctuation\">{</span>\n            loader<span class=\"token punctuation\">:</span> <span class=\"token string\">'style-loader'</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          <span class=\"token punctuation\">{</span>\n            loader<span class=\"token punctuation\">:</span> <span class=\"token string\">'css-loader'</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          <span class=\"token punctuation\">{</span>\n            loader<span class=\"token punctuation\">:</span> <span class=\"token string\">'less-loader'</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这样 loader 的问题就很轻松的解决了。</p>\n<h3>two：二解多实例并行前行</h3>\n<p>目前 webpack 上多线程多实例的方式有很多种，主要分为编译多实例和压缩多实例两个方面。</p>\n<h4>编译多实例</h4>\n<h5>happypack</h5>\n<p>编译多实例相信听到最多的应该是 happypack 这个东西，开启多线程进行 loader 编译。</p>\n<p>安装</p>\n<blockquote>\n<p>npm install happypack —save-dev or yarn add happypack —dev</p>\n</blockquote>\n<p>使用方式(引用一下 npm 上的例子)</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> HappyPack <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'happypack'</span><span class=\"token punctuation\">)</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  module<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    rules<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token punctuation\">{</span>\n        test<span class=\"token punctuation\">:</span> <span class=\"token regex\">/\\.js$/</span><span class=\"token punctuation\">,</span>\n        use<span class=\"token punctuation\">:</span> <span class=\"token string\">'happypack/loader'</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  plugins<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">HappyPack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      loaders<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'babel-loader?presets[]=es2015'</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>happypack 其原理就是：每次 webpack 解析一个模块，happypack 会将它及依赖分配给 worker 线程中编译。下面是 happypack 整体流程图。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/dbd0938cf371ca43ac437e68bbc3b3e3/4c7e8/happypack.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.34094368340944%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAPoAAAD6AG1e1JrAAABhUlEQVQoz41SyU7DMBT0t3JA/AUcuHHkiOgvIC6cOMChBVHUsnQhTUsjUkpKoITEW7zynLYsiQRYI2v87PEbj4z2T582D4Ltw2DrINg9nuZKGqv1/4B2jsK1vduNWme91gM9l06s/ilWWmtjNChghoo1KyxGaWlX3BUR4/qdqIy6mTC4zgJPsEqITgFUK2WltK7iiuodO2TUEGaQP83rXdwcsEYv64c5WLgJ6PlddunT9pC1RzlmJqWm0c/OvKzp0wuPNj1yPRbeo0CmcOH8go+KWfP5joLAATBii0iBI1jEcxW9SpiFMD+eWYItN0A8N60Buejh9oBhYpbbFRkXZhKrMJYPsXx61XGinLgcZAWLVoSbtk+uRrg1xF4o7qMcikhIG8yEQyRZXr5iobx/TvvTt3COgWAuvmznwnbH+GpEumNOq+IiyNZwdtKZXPpRvRe+EeaOFPn9bRvGPOPPCZ2n/CWh0sW93EJA4DNMYplg/XvO1QZO/BjLRicNIvFLZp/4Xv8AXQcmrhTk0O8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"happypack\"\n        title=\"happypack\"\n        src=\"/static/dbd0938cf371ca43ac437e68bbc3b3e3/799d3/happypack.png\"\n        srcset=\"/static/dbd0938cf371ca43ac437e68bbc3b3e3/00d96/happypack.png 148w,\n/static/dbd0938cf371ca43ac437e68bbc3b3e3/0b23c/happypack.png 295w,\n/static/dbd0938cf371ca43ac437e68bbc3b3e3/799d3/happypack.png 590w,\n/static/dbd0938cf371ca43ac437e68bbc3b3e3/4c7e8/happypack.png 657w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h5>thread-loader</h5>\n<p>现在 webpack4 已经不推荐使用 happypack 了，而是推荐使用 thread-loader，thread-loader 的原理和 happypack 类似， 其不同的地方是 thread-loader 可以人为设置对于哪种 loader 使用多少个线程来编译。</p>\n<p>安装</p>\n<blockquote>\n<p>npm install thread-loader —save-dev or yarn add thread-loader —dev</p>\n</blockquote>\n<p>使用方式：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  module<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    rules<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token punctuation\">{</span>\n        test<span class=\"token punctuation\">:</span> <span class=\"token regex\">/\\.js$/</span><span class=\"token punctuation\">,</span>\n        use<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n          <span class=\"token punctuation\">{</span>\n            loader<span class=\"token punctuation\">:</span> <span class=\"token string\">'thread-loader'</span><span class=\"token punctuation\">,</span>\n            options<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n              workers<span class=\"token punctuation\">:</span> <span class=\"token number\">4</span>\n            <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          <span class=\"token punctuation\">{</span>\n            loader<span class=\"token punctuation\">:</span> <span class=\"token string\">'babel-loader'</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面 thread-loader 使用 workers 配置了 4 个线程来编辑 js 文件。</p>\n<h4>压缩多实例</h4>\n<h5>uglify-webpack-plugin</h5>\n<p>第一种方式就是使用 webpack 内置的<code class=\"language-text\">uglify-webpack-plugin</code>这个插件，只需要配置一个 parallel 参数就可以，parallel 参数默认为当前电脑的 cpu 的核心数(os.cpus().length - 1)</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> UglifyJsPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'webpack/uglify-webpack-plugin'</span><span class=\"token punctuation\">)</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  optimization<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    minimizer<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">UglifyJsPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        parallel<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h5>terser-webpack-plugin</h5>\n<p>目前 webpack 的压缩使用的是这个插件，原因很简单：<code class=\"language-text\">uglify-webpack-plugin</code>压缩不了 ES6 的语法，而<code class=\"language-text\">terser-webpack-plguins</code>可以，并且在<code class=\"language-text\">terser-webpack-plguins</code>内部默认开启了缓存和多进程压缩。</p>\n<p>安装</p>\n<blockquote>\n<p>npm install terser-webpack-plugin —save-dev or yarn add terser-webpack-plugin —dev</p>\n</blockquote>\n<p>使用方式：和<code class=\"language-text\">uglify-webpack-plugin</code>一样 parallel 默认值为当前电脑的 cpu 核心数(os.cpus().length -1 )</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> TerserPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'terser-webpack-plugin'</span><span class=\"token punctuation\">)</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  optimization<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    minimize<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    minimizer<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">TerserPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        parallel<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>总结</h2>\n<p>上面总结的一些解决方案，基本上可以大幅度提高我们开发过程中的编译速度。</p>","frontmatter":{"title":"深入理解webpack痛点及解决方案","date":"October 15, 2019","description":"深入理解webpack的loader及单线程的问题，抛出解决方案","category":"Webpack"}}},"pageContext":{"slug":"/content/Webpack/webpck-thread-cary/","previous":{"fields":{"slug":"/content/Test/optimize-test-benchmark/"},"frontmatter":{"title":"Benchmark写性能测试"}},"next":{"fields":{"slug":"/content/Vue/vue-mixin/"},"frontmatter":{"title":"Vue的mixin机制及mergeOptions解析"}}}}}